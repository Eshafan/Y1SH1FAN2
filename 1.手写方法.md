# 1.手写call、apply、bind #
## 1.1 call ##
![](https://i.loli.net/2021/03/20/Un27R61vYE9PNJL.png)
分析：（1）该方法是被加载到函数的原型上的（2）context=“重新绑定的this”（3）...args=“代表call方法可以传入多个参数”（4）用symbol方法为新的属性创建一个名字（5）将function本身的this绑定到这个新的属性上（6）传参数（...args)(7)用完这个要删除
## 1.2 apply ##
![1.2apply.png](https://i.loli.net/2021/03/20/6xVHiYASRgBkoDs.png)
分析：与call的区别仅仅是参数可以是数组
## 1.3 bind ##
![1.3bind.png](https://i.loli.net/2021/03/20/34aWUx8crVmi62u.png)
分析：传参同call。主要区别是返回的函数并没有直接调用，而是需要传入新的参数去主动再调用(1)拼接新的参数（2）返回的是一个函数

# 2.手写jsonp #
### jsonp主要是利用script标签可以跨域加载的特性，实现跨域访问 ###
### 其它跨域方法：（1）CROS:跨域资源请求（Access-control-Allow-Origin:"*"或者"ip"（没有传cookie，要传的话，设置credential）（2）nginx方向代理：利用服务器之间可以实现跨域实现，把nginx当作中间传输层 ###
![2.1jsonp（1）.png](https://i.loli.net/2021/03/20/b6asphLxRtBr9eq.png)
![2.1jsonp（2）.png](https://i.loli.net/2021/03/20/nxSFTkjJycdsLQC.png)
分析：（1）创建script标签（2）前端的全局函数（3）服务端返回全局函数的调用
### 下面这种方法比较好理解jsonp，注意`cb&&cb（res）` ###
![2.2jsonp.png](https://i.loli.net/2021/03/20/FzvSI157YqJlrfC.png)

# 3.手写防抖和节流 #
## 都用的是 setTimeout ##
### 3.1 防抖（debounce） ###
防抖：以最后一次为准
![3.1debounce.png](https://i.loli.net/2021/03/20/v3FAKgCQly6p5Zs.png)
分析：把this看作是一个对象流程
### 3.1 节流（throttle） ###
节流：以第一次为准
![3.2throttle.png](https://i.loli.net/2021/03/20/8T623QrH7SkPsya.png)