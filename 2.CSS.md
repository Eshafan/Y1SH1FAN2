# 1.盒子垂直居中（5种方法） #
## （1）父：①diplay：flex/grid;② justify-conten：center;③align-items：center ##
### 原因分析：首先水平居中，然后再沿着交叉轴进行竖直居中 ###
![1css.png](https://i.loli.net/2021/03/20/gDbvL5sKwABl3za.png)
## （2）父：display：flex；子：margin：auto ##
### 原因分析：margin：auto意思就是边距全部平分 ###

![2css.png](https://i.loli.net/2021/03/20/a7IvjPlRruxDyht.png)
## （3）父：position：relative 子：①position：absolute②margin-top:50% margin-left:50% transform:translate(-50%,-50%) ##
### 原因分析：子元素以父元素为主进行定位，先把子的左上的点移到父元素的中心，然后再回退自己的50%实现居中 ###
![2css.png](https://i.loli.net/2021/03/20/a7IvjPlRruxDyht.png)
## （4）父：display：flex；子：①align-self：center ②margin：0 auto ##
### 原因分析：子元素先让自己垂直居中，再让左右水平方向的margin平分 ###

![2css.png](https://i.loli.net/2021/03/20/a7IvjPlRruxDyht.png)
## （5）父：position：relative  子：①position：absolute ②top：0 left：0 right：0 bottom：0 ③margin：auto##
### 原因分析：绝对于父元素定位，最终又要平分margin所以最终哪里也去不了，只能居中显示 ###
![5css.png](https://i.loli.net/2021/03/20/95PQny6p4SrtoIl.png)


# 2.清除浮动 #
浮动：由于没有给父盒子设计高度，给子盒子设置float后，父元素塌陷了
## 2.1手动计算给父元素设计高度（不推荐） ##
## 2.2在尾部添加一个块级元素，clear：both ##
分析：不要给加内容，让它属于正常流，和float元素一起去撑父盒子，因为float元素就是一个BFC了，有自己的独立区域
## 2.3在父元素尾部用单伪元素##
分析：`.clearfix::after{`
                `content: "";
                display: block;
                clear: both;
            }`
把这个clearfix类添加给父元素，以后需要清除浮动的父元素可以直接加上这个类就可以
## 2.4在父元素尾部用双伪元素 ##
分析：            `.clearfix::after,.clearfix::before{`
                `content: "";
                display: table;
            }
            .clearfix::after{
                clear:both;
            }`
用的是table，`*zoom：1` 为了浏览器的兼容性
## 2.5 把父元素创建成BFC（创建BFC的方法） ##
分析：①`overflow:hidden`;②`overflow:auto`;③`overflow：scroll`
④不能让父级元素也浮动起来创造BFC，这样子元素就是继承的父元素的浮动
（创建BFC的方法只能用overflow来清除浮动）

# 3.BFC #
### 3.1 BFC：浏览器的独立渲染模块 ###
#### 1.与周围的盒子互相不影响 ####
#### 2.高度要把浮动元素加进来 ####
#### 3.BFC里面的盒子只能竖直排放，一个接一个，按照margin（这里有一个问题，就是发生外边界重叠，明明是10px+10px，结果只有10px ####
#### 4.外部浮动元素也无法影响这个BFC ####
### 3.2创建BFC的方法 ###
#### 1.根html本身就是一个大的BFC ####
#### 2.`overflow：hiden/auto/scroll`（应用清除浮动） ####
#### 3.`float！=none` （只要有浮动就是BFC，互不影响） ####
#### 4.diplay：行内块（inline-block）/flex/table-cell ####
#### 4.`position：absolute/fixed`，这种脱离了正常``文档流的 ####

# 4.css的选择器的优先级 #
！important>style属性>id（#）>class(.)>tag(直接写名字)？*>继承


# 5.三栏布局 #
## 1.圣杯布局（中左右）实现中间的自适应 ##
    `        <div class="wraper">
            <div class="center">center</div>
            <div class="left">left</div>
            <div class="right">right</div>

        </div>`
    `
				.wraper{
                background-color: violet;
                padding-left: 100px;
                padding-right: 200px;
            }
            .center{
                /*实现中间栏的自适应*/
                height: 200px;
                width: 100%;
                background-color: tomato;
                float: left;
            }
            .left{
                height: 200px;
                width: 100px;
                background-color: rgb(30, 230, 230);
                float: left;
                position: relative;
                margin-left: -100%;
                left:-100px;
                /* 
               
                left:-100px; */
            }
            .right{
                height: 200px;
                width: 200px;
                background-color: yellowgreen;
                float: left;
                margin-right: -200px;
            }
            .wraper::after{
                content: '';
                display:block;
                clear: both;
            }
`
，
总结圣杯布局：1、中间先渲染的原因是因为最先呈现内容
2、全部内部都用float：left 进行统一排列（中左右）
3、让wraper设置一个padding，宽度分别为左右的定宽，让左右浮上去填充padding
4、left设置一个**margin-left：-100%**，是相对于wraper的，意思就是把它移出去，距离conten自身-100%的位置，最后再设置它的position：relative，相对于自己距离left：-自己的宽度 5、right-right：-自己的宽度 ，就被挤上去了。是为了挤中间的div


## 2.双飞翼模型 ##
    `
 			<div class="center">
             center
            <div class="inner"></div>
            </div>
            <div class="left">left</div>
            <div class="right">right</div>
        
`

    `
		*{
                box-sizing: border-box;
                margin: 0;
                padding: 0;
            } 
            .center{
                height: 200px;
                width: 100%;
                background-color: violet;
                float: left;
            }
            .left{
                width: 100px;
                height: 200px;
                background-color: yellow;
                float: left;
                margin-left: -100%;
            }
            .right{
                width: 200px;
                height: 200px;
                background-color: blue;
                float: left;
                margin-left: -200px;
            }

            .inner{
                margin-left: 100px;
                margin-right: 200px;

            }
`
双飞翼模型总结：1、加载顺序任然是中左右，因为要先看内容 2、在center里面嵌套一个inner盒子 3、依然是全部float：left；弄成一行，里面的inner最终是不会显示的，所以什么都不用设置，只需要用它去设置margin，目的是去撑起外面的center。让center不直接有外边距，好让它自由伸缩。4、left：margin-left：-100%，直接跑上去 5、right：**margin-left：-自己的宽度**（与圣杯布局不同之处）


## 3.float 布局 ##
    `<div class="left">left</div>
         <div class="right">right</div>
        
         <div class="center">center</div>
         `

    `* {
            padding: 0;
            margin: 0;
            box-sizing: border-box;
        }

        .left {
            width: 100px;
            height: 200px;
            background-color: chartreuse;
            float: left;
        }

        .center {
            height: 200px;
            width: 100%;
            background-color: cadetblue;
            margin-left: 100px;
            margin-right: 200px;
        }

        .right {
            height: 200px;
            width: 200px;
            background-color: darkgreen;
            float: right;
        }`

float布局总结分析：1、左右各float：left和right 
**> ** 2、重点注意顺序（左右中）****
3、中间元素给margin，margin就是左右的宽度


## 4、absolute 绝对定位布局 ##

    `<div class="left">left</div>
    <div class="center">center</div>
    <div class="right">right</div>

`
    `*{
            margin:0;
            padding:0;
            
        }
        .left{
         width: 100px;
         height: 200px;
         background-color: darkgreen;
         position: absolute;
         top:0;
         left:0;
        }
        .center{
        height: 200px;
        background-color: darkorange;
        margin-left: 100px;
        margin-right: 200px;
        }
        .right{
        width: 200px;
        height: 200px;
        background-color: darkmagenta;
        position:absolute;
        top:0;
        right:0}`

absoulute：方法总结：1、与dom树的位置无关 2、left和right分别绝对定位，绝对于他们的父窗口，也就是html，从边缘部分开始。3、center给他们留出响应的margin就可以了


## 5、Flex布局 ##

    `<div class="wraper">
    <div class="left">left</div>
    <div class="center">center</div>
    <div class="right">right</div>
</div>`

    `.wraper{
            display: flex;
        }
        .left{
            height: 200px;
            width: 100px;
            background-color: darkorange;
        
        }
        .center{
            height: 200px;
            background-color: darkred;
            flex:1;
        }
        .right{
            height: 200px;
            width: 200px;
            background-color: darkviolet;

        }`
felx布局总结：1、有一个外包元素wraper：要设置它的display为flex去弹性伸缩
2、center：flex：1（代表flex）优先考虑它，与dom顺序有关，最好左中右依次排

## 6、grid布局 ##
		<div class="wraper">
		<div class="left">left</div>
		<div class="center">center</div>
		<div class="right">right</div>
		</div>
`

    .wraper{
            display: grid;
            grid-template-columns: 100px auto 200px;

        }
        .left{
            width: 100px;
            height: 200px;
            background-color: darkviolet;

        }
        .center{
            height: 200px;
            background-color: deepskyblue;
        }
        .right{
            height: 200px;
            width: 200px;
            background-color: firebrick;
        }
总结grid布局：只需要在外面的wraper上设置display和 grid-template-columns: 100px auto 200px;，两边的宽度固定，中间auto
  
#  6.css的position属性#
## （1）fixed：脱离文档流，固定在浏览器窗口的某个位置。 ##
## （2）absolute：脱离文档流，相对于父盒子的绝对定位，方位定位有意义 ##
## （3)relative:相对定位，相对于自己的本身的位置的定位，自己以前的位置还是不变，没有脱离文档流 ##
    `<!DOCTYPE html>
	<head>
    <style>
        .all{
            width: 100px;
            height: 100px;
            padding: 0;
            margin:0
        }
        .absolue{
            background-color: blue;
            position: absolute;
            top:100px;
            left:100px;
        }
        .relative{
            background-color: brown;
            position:relative;
            /* 相对于自身本身的位置，其本身还是占着文档流，接下来的div还是跟着排 */
            top:1200px;
            left:100px;
        }
        .static{
            background-color: chartreuse;
            position: static;
            /* 设置left和top无效 */
            left: 200px;
            top: 200px;
        }
        .fixed{
            background-color: darkgreen;
            position: fixed;
            left:400px;
            top:500px;
        }
    </style>

	</head>
	<body>
	<div class="absolue all">absolue</div>
	<div class="relative all">relative</div>
	<div class="static all">static</div>
	<div class="fixed all">fixed</div>
	</body>
	</html>`