# 1.对MVVM（发布者-订阅者模式）的理解 #
## 自我理解：M:model（数据模型） V：view（视图模型） VM：view-model（数据桥梁）自动渲染&自动更新 ##

### 作用：简化了界面与业务的依赖，解决了数据的频繁更新，双向绑定技术。自动变化！！！注意自动 ###
### MVC（观察者模式）的对比。C：controller =>视图提交数据修改请求，由控制器去修改数据。数据修改则选择性的视图再改变 ###
![](https://images2015.cnblogs.com/blog/811883/201704/811883-20170423150024694-1439613206.jpg)


# 2.Vue实现双向绑定的原理：Object.property.define（） #
# 采用数据劫持结合发布者订阅者模式 #
## 自我理解：采用的是：通过Object.property.define（）方法，去劫持各个属性的setter 和 getter ，在数据变动时，发布消息给订阅者##

## observer   compile  watcher ##
### 通过observer 来监听自己的model的数据变化，通过compile 解析编译模板指令（解析胡子语法），最终利用watcher 搭起桥梁 ###



# 3.Vue 的生命周期 #
## 1.8个生命周期阶段：创建前后，载入前后，更新前后，销毁前后 ##

## （1）什么是生命周期：（vue实例从创建到销毁的全过程） ##
### 也就是开始创建、初始化、编译模板、挂在dom、渲染、更新再渲染，最后再销毁的整个过程 ###


## （2）各个生命周期的作用 ##
1. beforeCreate（） ：组件实例被创建初期，光有组件，属性都没有

2. created（）：组件已经被完全创建，属性绑定了，但是没有dom，意思就是没有值，$el：还不可以用，没有绑定好

3. beforeMounted（）：挂载之前被调用，相关的渲染函数第一次被调用   

4. mounted（）：挂载到实例上(只要执行完这一步，说明实例化已经进行完毕，进入到运行阶段）DOM渲染在这个阶段完成
	以上执行完成后，第一次页面加载就触发以上的几个钩子

5. beforeUpdate（）：组件更新前被调用，发生在虚拟DOM

6. updated（）：组件更新之后调用

	actived：keep-alive 专属，更新了之后不立即渲染dom树，而是暂存

7. beforeDestory（）：组件销毁之前调用
8. destory：组件销毁之后调用
## （3）Vue生命周期的作用：有很多事件钩子，控制vue实例的过程 ##


# 4.Vue 组件的参数传递 #
## 4.1 父——>子 ：props方法##
## 4.2 子——>父 ：$emit方法 ##
## 4.3 兄弟之间：创建一个事件中心中转站：非父子组件之间的通信一般通过一个空的 Vue 实例作为 中转站，也可以称之为 事件中心、event bus（或者用VUEx）##


##不懂VUEx：vuex 是通过将 state 作为数据中心、各个组件共享 state 实现跨组件通信的，此时的数据完全独立于组件，因此将组件间共享的数据置于 State 中能有效解决多层级组件嵌套的跨组件通信问题。 ##

    `// 创建事件中心实例
	let bus = new Vue()
	
	// 在组件 A 中触发事件
	bus.$emit('test', 1)
	
	// 在组件 B 中接受事件
	bus.$on('test', (id) => {
	// ...
	})`

# 5.Vue的路由实现（hash和history） #
### 1.hash：再URL后加#号表示，window.location.hash来读取，不会重新加载页面，因为不会被包含在http的请求中间 ###

### 2.history 模式：两个方法pushstate（）replacestate（），对浏览器的历史记录栈进行修改，以popstate（）事件的监听到的状态变更 ###

> 补充：路由跳转

    `声明式跳转（标签跳转）：<router-link :to='index`>
	 编程式跳转（JS跳转）：router.push('index')

# 5.VUEX（全局变量）让其他组件可以用（是一个容器，放东西用的），维护公用变量和方法 #
## 1.是什么：vuex只是vue的一个插件 ##
## vuex就是一个存放多个组件共用的一个数据的存放、更改、处理的一个容器，就是说来存放处理公共数据的工具，存放的数据一变，各个组件都会更新，也就是说存放的数据是响应式的。 ##


## vuex 就是把需要共享的变量全部存储在一个对象里面，然后将这个对象放在顶层组件中供其他组件使用 ##
store：
> state：存储状态，也就是变量
> getters：同get
> mutations：同set 提交修改状态（只支持同步）
> store.commit:同method
> actions：同mutations（支持异步）
> model：相当于store的一个实例，项目特别复杂的时候，可以让每一个模块拥有自己的以上属性

## 应用场景：（1）解决跨组件通信问题(数据库store) :音乐播放，加入购物车##


# 6.v-if 和 v-show #
## if是有没有，show是显示不显示（其实是有的，占了DOM树） ##

# 7.如何让css只在当前组件起作用 #
    `<style scoped>`
## 避免组件之间样式污染 ##

# 8.<keep-alive></keep-alive>的作用 #
## 组件缓存actived/deactived（只在这个时候用）（也就是组件被激活）两个生命周期 ##

##保留组件状态，避免重新渲染  ##

### 举例：用户查看详情和返回列表，反复操作，则可以进行缓存，直接从缓存中拿，避免重复渲染 ###

# 9.el的作用 #
## 将DOM元素和Vue实例进行绑定（挂载） ##

# 10.vue中使用插件 #
## import form（引入） ##

# 11.VUe的优点 #
1. 低耦合
2. 可重用性
3. 可测试

# 12.vue 的data 为什么必须是函数 #

## 因为每一个组件都是vue实例，组件共享data属性，当data的值是一个引用类型的时候（对象），则所有组件，也就是vue实例之间都是共享的 ##

# 13.proxy（3.0） 和 object.defineProperty的优势（都是用来实现双向绑定的） #
    `const p = new Proxy(target, handler)`


> 1.Proxy使用上比Object.defineProperty方便的多

> 2.Proxy代理整个对象(但是只要第一层），Object.defineProperty只代理对象上的某个属性。

> 3.如果对象内部要全部递归代理，则Proxy可以只在调用时递归，而Object.defineProperty需要在一开始就全部递归，Proxy性能优于Object.defineProperty。

> 4.对象上定义新属性时，Proxy可以监听到，Object.defineProperty监听不到。

> 5.数组新增删除修改时，Proxy可以监听到，Object.defineProperty监听不到。

> 6.Proxy不兼容IE，Object.defineProperty不兼容IE8及以下。


# 14.vue 和 react 和 angular #


> A：typescript V:javascript/typescript

> V：组件分全局和局部 R：import响应组件

> V：有作用域插槽，可以让子组件有自己的模板，还有语法糖


# 15.computed 和 watch #

> computed：计算属性，有缓存性，只有在他依赖的属性值改变之后，才会重新调用getter来计算，适用于计算消耗性能的场景（某些数据依赖其他数据进行变动）

> watch：用于观察props $emit 或者组件本身的值，当数据变化的时候，回调进行后续的操作，无缓存性，页面重新渲染值不变也不会执行，只关注值（数据变化的同时进行异步操作或者比较大的开销）


# 16.ref的作用 #

> 1、获取dom元素
> 2、获取子组件中的方法
> 3、获取子组件中的信息



# 17.vue修饰符 #
> 1.stop：阻止冒泡（stoppropagation）（））

> 2.prevent：组织默认行为(preventDefault())

> 3.once:只触发一次

> 4.self：只触发自己的事件行为

# 18.性能优化 #
> 1、循环调用子组件用key（通过这个，可以让diff操作更准确，更快速，尽可能复用DOM元素）

> 2、频繁切换用v-show而不是v-if

> 3、按需加载 require

> 4、路由懒加载（不懂）

> 5、webpack层面进行优化：（1）图片压缩 （2）common chunk plugin：进行提取公共代码 （3）提取css组件

# 19.diff算法:同层的树节点进行比较的高效算法，避免了对树进行逐层搜索遍历，时间复杂度（o（n）） #
#### 应用：vue虚拟dom渲染成真实dom ####

### diff 算法的核心是对比新旧节点的 children，更新 DOM ###

    `
	（1）只进行同级比较，不会跨层比较
	（2）标签名不同，直接删除，不继续再深度比较
	（3）标签名相同看key想不想同，如果key相同则就是相同节点
	`


# 20.nextTick：在下次DOM更新循环结束之后，执行延迟回调，用于获得更新后的DOM #
## 主要使用宏任务和微任务 ##

# 21.接口请求一般放在mounted中，但是在服务端渲染时是不支持mounted的，所以需要放在created中 #

# 22.v-model原理 #
## 语法糖 ##
## value+input  ##

#23.vue事件绑定原理  addeventlistener#
addeventlistener（对象，事件，冒泡/捕获）

# 24.vue编译原理：将teplate转换为render函数的过程 #


# 25.SSR（服务端渲染） #
### 再服务端完成将标签渲染成html，再返回给客户端 ###

### 好的SEO：搜索引擎优化 受屏加载快速 ###

### 服务端渲染只接受beforecreated 和created两个钩子 ###


# 26.vue.cil 项目中src目录中每个文件的作用 #

> assets：存放静态资源

> components：放组件

> router：放路由配置

> main.js：入口文件

# 27、动态绑定class： #

    `<div :class="{active:isActive}"</div>`