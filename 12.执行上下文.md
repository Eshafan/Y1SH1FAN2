# 1.执行上下文：当执行到一个函数的时候的准备工作 #

## 工具：执行上下文栈 ##
## 当js执行到一段可执行代码时，就会创建执行上下文，执行上下文的三个重要属性 ##
> 1、变量对象 2、this 3、作用域链
    
`变量对象：与执行上下文相关的数据作用域，保护上下文中定义的变量声明和函数声明`
> 1、全局对象：window对象是浏览器中的全局对象 /任何全局变量或者函数都可以通过window的属性来访问 /顶层可以用this来引用全局对象

> 2、活动对象：只有当进入一个执行上下文中，这个执行上下文的变量对象才会被激活，只有被激活的对象，它里面的属性才能够被访问，通过arguments属性来激活里面的变量


# 2.执行过程：分析+执行 #
##2.1 分析=进入执行上下文 ##
> 刚刚进入执行上下文阶段，还没有执行代码

> 所以此时的变量对象：1、函数的所有形参（对象变量名字，但是值为undefined） 2、函数声明 3、变量声明

    `function foo(a) {//1、函数的形参a=1
    var b=2;//变量声明 b=undefined
    function c() {}//函数声明 c=reference to function c（）{}
    var d =function(){};//变量声明 d= undefined
    b=3;//变量声明，这种相当于全局声明
	}
	foo(1)`
##2.2 执行=代码执行 ##
> 顺序执行代码，根据代码，修改变量对象的值

上面的例子，代码执行完成后
> a=1
> 
> b=3//进行了覆盖

> c=function（）{}

> d=function（）{}


> 全局上下文的变量对象初始化是全局对象

> 函数上下文的变量对象初始化只包括Arguments对象（arguments 属性值是Arguments对象）

> 在进入执行上下文时，会给变量对象添加形参，函数声明，变量声明

> 在代码执行阶段，会再次修改变量对象的属性值



### 思考题1 ###
    `function foo(){
    console.log(a);
    a=1;
	}
	foo();//报错，因为并不是var声明了这个变量，只有var声明才提前
	function bar(){
	    a=1;
	    console.log(a);
	}
	bar();//1，这里的a不是在函数内部，而是全局的，向外找，找到了全局的a`
### 思考题2 ###
    `console.log(foo);//[Function: foo] 函数声明是可以提前的
	function foo(){
	    console.log('foo');//
	}
	var foo=1;//这个foo对第一个foo要进行一个覆盖
	console.log(foo);//1`
### 思考题3 ###
    `var foo =1;
	console.log(foo);//1
	function foo(){
	    console.log("foo")
	}`
# 3.作用域链 #
#### 找变量的时候，首先从当前上下文中的变量对象去找，没有的话就找父级作用域中的，最终找的是window，也就是全局，如果没有就报错 ####
### 作用域链的定义：有多个执行上下文的变量对象构成的链表 ###

# 4.函数书写 #
### 当书写一个函数的时候，就会创建词法作用域，这个作用域是函数的内部属性，用[[scope]]表示 ###
# 5.函数调用 #
## 函数调用，函数被激活，创建函数上下文，创建活动对象 ##

# 6.词法作用域：由代码写的位置决定 #