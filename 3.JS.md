# 1.原始值和引用值类型及区别 #
#### 原始值：number/string/boolean/symbol/null/undefined ####
#### 引用值：function/array/set/map ####
#### 区别：（1）保存位置：一个在堆内存（堆内存保存到是它的指针），一个在栈内存 ####


#2.判断数据类型的常用方法  #
#### （1）typeof 返回的是具体的数值类型，null-object ####
    `console.log(typeof(null))//object
	console.log(typeof(1))//number
	console.log(typeof('1'))//string
	let p=Symbol()//一定注意symbol不能用作构造函数
	console.log(typeof(p))//symbol
	console.log(typeof('false'))//string
	console.log(typeof(false))//Boolean
	console.log(typeof(undefined))//undefined`
#### （2）instanceof 要指定猜的类型 ####
#### 重点：需要用到instanceof来检测某个对象是不是另一个对象的实例。 ####
####基本引用类型： Object、Array、Date、RegExp、Function、基本包装类型（Boolean、Number、String）） ####
    `console.log(1 instanceof (Number))//false
	console.log(false instanceof(Boolean))//false
	console.log('false' instanceof(String))//false
	console.log(Symbol('foo') instanceof(Symbol))//false
	// console.log(undefined instanceof(undefined))//无法判断
	// console.log(null instanceof(null))//无法判断
	let p=function () {}//无法判断
	// console.log(p instanceof (Object))//无法判断`
#### 下面这个才是对的 ####
    `let p = new Date()
	console.log(p instanceof Object)//true
	console.log(p instanceof Date)//true`

#### 3.Object.prototype.toString() ####
## console.log(Object.prototype.toString(NaN))//[object Object] ##
## console.log(NaN.constructor)//[Function: Number] ##
#### 因为Array，Function，Date虽然是基于Object进行创建的，但是他们继承的是Object.toString()，而不是Object.prototype.toString()。 ####
    `
	console.log(Object.prototype.toString.call([1,2,3]))//[object Array]
	console.log(Object.prototype.toString.call([123].toString()))//[object String]
	console.log(Object.prototype.toString.call(Boolean))//[object Function]
`
分析：将【1，2，3】作为参数传给当前object的原型，并转换成为字符串，则当前对象的这个属性变成了数组类型，同样，第二个变成string类型，第三个传了一个构造函数进去，所i变成了function类型对象，是往原型上面传的，全部都转化为了对象

    `console.log(Object.prototype.toString.call([1,2,3]))//[object Array]
	console.log(Object.prototype.toString.call([123].toString()))//[object String]
	console.log(Object.prototype.toString.call(Boolean))//[object Function]
	console.log(Object.prototype.toString.call(1))//[object Number]
	console.log(Object.prototype.toString.call('1111'))//[object String]
	console.log(Object.prototype.toString.call(true))//[object Boolean]
	console.log(Object.prototype.toString.call(Symbol()))//[object Symbol]`
#### 4.constructor ####
### console.log(NaN.constructor)//[Function: Number] ###
### 使用constructor 的原理是：利用对象原型上的constructor指向的是构造函数，打印出构造函数的类型从而判断类型 ###
### 缺点：如果人为的去改变该对象的原型上的constructor的指向，则无法准确判断 ###
    `console.log(constructor (1))//[Number: 1]
	console.log(constructor (true))//[Boolean: true]
	console.log(constructor ('1111'))//[String: '1111']
	console.log(constructor (Symbol('foo')))//[Symbol: Symbol(foo)]
	console.log(constructor (null))//{} 无法检测
	console.log(constructor (undefined))//{} 无法检测
	let p = function(){}
	console.log(constructor (p))//[Function: p]
	let q=new Date()
	console.log(constructor (q))//2021-03-25T01:22:15.043Z 无法检测
	console.log(constructor ([1,2,3,4,5]))//[ 1, 2, 3, 4, 5 ]无法检测`
总结：无法检测null和undefined

# 3.类数组和数组的区别与转换 #
只知道function里面的arguments是类数组，类数组只能用数组的length方法，其余的都不能用吧，如何转换不知道
#### 以下是错误的（arguments的用法)!!! #####
    `let p = function (a,b,c) {
    	return this.arguments
		}
		console.log(p())`
#### ANS:类数组对象，如 arguments 对象、NodeList 对象等，类数组对象有length属性，可以通过数组下标取值，但是类数组对象不能调用数组原型上的方法 ####

# 4.数组常见的 API  #
#### 也就是数组常见的方法 ####
#### （1）fill(value, start, end):将数组start到end的值用value填充 ####
#### 注意：数组本身已经被改变了，并且end不能超过原来数组的长度 ####
    `let arr1 = [1,4,5,6,7]
	console.log(arr1.fill(0,4,100))//[ 1, 4, 5, 6, 0 ]
	console.log(arr1)//[ 1, 4, 5, 6, 0 ]`

#### （2）pop（） 弹出数组最后一个值，然后将其返回，数组本身已经被改变了（不用带参数）####
    `let arr1 = [1,4,5,6,7]
	console.log(arr1.pop())//7
	console.log(arr1)//[ 1, 4, 5, 6 ]`
#### （3）push（参数）向数组末尾增添元素，数量不限，最后返回的是目前数组的总元素个数，且数组本身被改变  ####
    `let arr1 = [1,4,5,6,7]
	console.log(arr1.push(1,2,3,4,5))//10
	console.log(arr1)//[ 1, 4, 5, 6, 7,1, 2, 3, 4, 5]`
#### （4）reverse（）反转数组，原数组改变，不用带参数 ####
    `console.log(arr1.reverse())//[5, 4, 3, 2, 1,7, 6, 5, 4, 1]
    console.log(arr1)//[5, 4, 3, 2, 1,7, 6, 5, 4, 1]`
#### （5）shift 和 unshift ####
#### shift是它能够移除数组中的第一项并返回该项，同时将数组长度减1，不管参数是多少，都是移除第一项，可以不带参数####
    `let arr1 = [3,4,5]
	console.log(arr1.shift())//3`
	console.log(arr1)//[ 4, 5 ]
#### unshift带参，增添多项在头部，返回的是数组的长度，并且原数组改变 ####
    `let arr1 = [3,4,5]
	console.log(arr1.unshift(9,2))//5
	console.log(arr1)//[ 9, 2, 3, 4, 5 ]`
####（6）sort 排序  ####
    `console.log(arr1.sort())//[ 2, 3, 4, 5, 9 ]`
#### （7）splice（从哪个删，删几个）进行删除 ####
> slice（start，end）===》进行切分
    `let arr1 = [3,4,5]`

    `不带参数的拆分，一个都没有拆出来
	console.log(arr1.splice())//[]
	从下标为1，拆到下标为2，两头都包含
    `console.log(arr1.splice(1,2))//[ 4, 5 ]
	console.log(arr1)//[ 3 ]原数组改变`
	只设定一个参数的，代表一直到末尾
    `let arr2 = [3,4,5,6,7,8,9]
	console.log(arr2.slice(3))//[ 6, 7, 8, 9 ]`
**以上几种都是改变了数组自身的**
#### （8）concat（）拼接，不改变自身了 ####
    `let arr1 = [3,4,5,6,7,8,9]
	let arr2=[10,11,12,13]
	console.log(arr1.concat(arr2))//[3,4,5,6,7,8,9,10,11,12,13]
	console.log(arr1.concat([1,2,3]))//[3, 4, 5, 6, 7,8, 9, 1, 2, 3]
`
#### （9）includes是否包含某个具体值 ####
    `let arr1=[1,2,3,4,5]
	console.log(arr1.includes(3))//true
	console.log(arr1.includes(3,2))//true
	console.log(arr1.includes(6))//false`
#### （10）join用后面的字符串来进行拆分连接（数组改编成字符串，并且指定拼接符） ####
    `let arr1=[1,2,3,4,5]
	console.log(arr1.join(9999))//199992999939999499995
	console.log(arr1.join('_'))//1_2_3_4_5
	console.log(arr1.join(false))//1false2false3false4false5`
#### （11)slice() 本来是字符串的方法，对字符串进行拆分，也可用于数组，和splice的区别splice重点在删，从哪个开始删，删几个）####
    `let arr1=[1,2,3,4,5]
	let string='yishifan'
	console.log(string.slice(2))//shifan
	console.log(arr1.slice(3))//[ 4, 5 ]
	console.log(arr1.slice(1,2))//[ 2 ]`
#### （12）indexOf()返回对应参数第一次出现所在数组下标，lastindexof返回指定元素在数组中最后一次出现的下标值，如果没有则返回-1 ####
    `let arr1=[1,2,3,4,5]
	console.log(arr1.lastIndexOf(2))//3
	console.log(arr1.indexOf(1))//0
	console.log(arr1.indexOf(9))//-1`
#### （13）every(function) 方法用于检测数组所有元素是否都符合指定条件（通过函数提供） ####

#### 是用来判断的，返回的是布尔值 ####
    `let judgemnet=function(n){
    return n>0;
	}
	let arr1=[1,2,1,2,3,4,5,3,4,5]
	console.log(arr1.every(judgemnet))`
#### （14)some（function）其中某一些满足函数（打平数组） ###
    `while(arr.some((item)=>Array.isArray(item){
		arr=[].concat(...arr));

		return arr;`

#
    `let judgemnet=function(n){
        return n>4;
    }
	let arr1=[1,2,1,2,3,4,5,3,4,5]
	console.log(arr1.some(judgemnet))`

#### （15）map(function) 返回一个数组，每一个执行后的结果是true还是false ####
    `let judgemnet=function(n){
        return n>4;
    }
	let arr1=[1,2,1,2,3,4,5,3,4,5]
	console.log(arr1.map(judgemnet))
	//[
	  false, false, false,
	  false, false, false,
	  true,  false, false,
	  true
	]`
#### （16）redeuce （累加器）没有掌握 ####
#### （17）forEach 把每一个拿出来操作####
	    `let arr1=[1,2,1,2,3,4,5,3,4,5]
		arr1.forEach((item)=>{
	    console.log( item*10)
	})
		//10201020304050304050`

#### （18）filter过滤器 ####
    `arr1.filter((item)=>{

     console.log(item>3)
	})
	//false false false false false true true false true true
`
# 5.bind,call,apply的区别 #
#### （1）call和apply，call只能接受一个一个的参数，而apply可以接受一个数组，传给对象的参数的时候 ####
#### （2）bind不是立即调用的函数，而call和apply是立刻调用的 ####
#### （3）都是用来改变this指向的，箭头函数中间就没有 ####
    `let obj={
    a:2,
    fn:function () {
        console.log(this.a)
    }
	}
	let obj2={
	    a:999
	}
	obj.fn()//2
	obj.fn.apply(obj2)//999
	改变了this的指向，但是并没传参，因为obj2是一个对象，不需要参数`

### 1.改变this指向，不传参 ###
	    `let name='易诗凡',age=24;
	let father={
	    name:"易文远",
	    fatherAge:this.age,
	    fatherMsg:function(){
	        console.log(this.name+'年龄'+this.age);
	        // console.log(this);
	    }
	};
	let mother={
	    name:"姚春惠",
	    age:50
	};
	console.log(father.fatherAge);//24 undefined
	father.fatherMsg();//易文远年龄24 易文远年龄undefined
	father.fatherMsg.call(mother);//姚春惠年龄50
	father.fatherMsg.apply(mother);//姚春惠年龄50
	father.fatherMsg.bind(mother)();//姚春惠年龄50`

遇到的问题：father里面的this.age，取不到外部的age
### 2.传参 ###
	    `let name='易诗凡',age=24;
		let father={
	    name:"易文远",
	    fatherAge:this.age,
	    fatherMsg:function(hobby,eat){
	        console.log(this.name+'喜欢'+hobby+'爱吃'+eat);
	    }
	};
	let mother={
	    name:"姚春惠",
	    age:50
	};
	console.log(father.fatherAge);//undefined
	father.fatherMsg();//易文远喜欢undefined爱吃undefined
	father.fatherMsg.call(mother,'唱歌','火锅');//姚春惠喜欢唱歌爱吃火锅
	father.fatherMsg.apply(mother,['唱歌','火锅']);//姚春惠喜欢唱歌爱吃火锅
	father.fatherMsg.bind(mother,'唱歌','火锅')();//姚春惠喜欢唱歌爱吃火锅`
bind传参和call一样，传的参是本身里面函数需要的参数
### 3.利用call和tostring可以判断类型 ###
    `console.log(Array.prototype.toString.call(1))//1`
# 6.new的原理 #
#### new执行四步：（1）创建一个对象 ####
#### （2）将空对象的原型链 _proto_指向父的原型 ####
#### （3）执行构造函数中的代码，并改变this指向到这个新的对象（this可能在构造函数里，也可能在原型上） ####
#### （4）如果函数没有返回值，那么就返回这个对象 ####
    `function _new(){
    let obj={}
    let [Con,...args]=arguments
    obj._proto_=Con.prototype
    let res = Con.apply(obj,args)
    return res instanceof Object ? res :obj
}`

    `function Person(name,age){//创建构造函数
    this.name=name;
    this.age=age;
	}
	Person.prototype.getName=function () {
	    return this.name
	}
	let person=new Person('易诗凡',24)
	console.log(person)//Person { name: '易诗凡', age: 24 }`
# 7.如何正确判断this（this 是在运行时进行绑定的） #
## this的绑定和函数声明的位置没有任何关系，只取决于函数的调用方式 ##
### 1.误解1：一种是认为 this 指向函数自身 ###
    `function foo(num) {
    console.log("foo:"+num);
    this.count++;//此时的this并不是指向foo这个函数,而是创建了一个全局的count
	} 
	foo.count=9;//给foo函数对象中添加了一个count属性值
	for(let i =0;i<5;i++){
	    foo(i);//一次打印foo：0——4
	}
	console.log(foo.count);//9
	以上this的指向并不是这个函数本身内部的count，而是单独创建了一个count，foo.count里面的count才是函数内部的，并且this.count的作用域在函数调用完之后就消失了`

### 2.误解2：this指向函数的作用域。需要明确的是，this在任何情况下都不指向函数的词法作用域 ###
	    `function foo() {
	    let a =2;
	    this.bar();
	}
	function bar() {
	    console.log(this.a)
	}////ReferenceError: a in not defined`
## this 既不指向函数自身也不指向函数的词法作用域，this 实际上是在函数被调用时发生绑定的。 ##
	    `function baz(){
	    console.log("baz");//调用栈baz
	    bar();//baz-bar
	}
	function bar(){
	    console.log("bar");
	    foo();//baz-bar-foo
	}
	function foo(){
	    console.log("foo")
	}
	baz();`
以上代表函数的嵌套调用，注意调用到的位置，才好确认this的指向
## 3.this的绑定规则 ##
### 3.1默认绑定 相当于全局window调用foo（），那么this动态指向window所以目前的this.a应该是2，this不是指向函数作用域里面的a，而是和函数同一个作用域里面的a ###
    `function foo(){
    console.log(this.a);
	}
	var a =2;
	foo();//严格模式：undefined
			非严格模式：2，指向全局对象`
### 3.2隐式绑定 ###
    `function foo(){
    console.log(this.a);
	}
	var obj ={
	    a:2,
	    foo:foo
	};
	obj.foo();//2
	当函数引用有上下文对象时，隐式绑定的规则会把函数调用中的 this 绑定到这个上下文对象`


    `this指向最靠近它的那一层作用域
	function foo(){
	    console.log(this.a);
	}
	var obj1 ={
	    a:1000,
	    foo:foo
	};
	var obj2={
	    a:-9999,
	    obj1:obj1
	}
	obj2.obj1.foo();//1000`
#### 隐式丢失：是最后调用它的那一层函数同级的作用域bar（）是最外层，相当于window ####
    `function foo(){
    console.log(this.a);
	}
	var obj1 ={
	    a:1000,
	    foo:foo
	};
	var bar=obj1.foo;//函数别名
	var a='oops.global';
	
	bar();//undefined or 'oops.global'(分模式)`
第二种模式？？？？？没看懂这个为什么不打印2
#### 是和obj同级的a，那就是全局的a ####

    `function foo(){
    console.log(this.a);
	}
	function deFoo(fn){
	    fn();
	}
	var obj={
	    a:2,
	    foo:foo
	};
	var a='oops,global';
	deFoo(obj.foo);//'oops,global'`

第三种模式是和obj同级的a，不是obj里面的a

    `function foo(){
    console.log(this.a);
	}
	var obj={
	    a:2,
	    foo:foo
	};
	var a='oops,global';
	setTimeout(obj.foo,1000);//'oops,global'`
#### 回调函数丢失 this 绑定是非常常见的 ####

### 3.3显示绑定 ###
    `
	function foo(){
	    console.log(this.a);
	}
	var obj ={
	    a:2
	};
	foo.call(obj)`
#### 本来是和foo同级的a，但是由于call硬要改变this的指向，指向了obj，所以里面的a就是obj里面的a ####


### 硬绑定 ###
    `	function foo(){
    console.log(this.a);
	}
	var obj ={
	    a:2
	};
	var bar=function () {
	    foo.call(obj);
	}
	setTimeout(bar,1000);//2
	bar.call(window);//2
`

### 
    函数是否在 new 中调用（new 绑定）？如果是的话，this 绑定的是新创建的对象。
    函数是否通过 call、apply 显示绑定或者硬绑定？如果是的话，this 绑定的是指定对象。
    函数是否在某个上下文中调用（隐式绑定）？如果是的话，this 绑定的是那个上下文对象。
    如果都不是，使用默认绑定。严格模式下绑定到 undefined，否则绑定到全局对象。
 ###

### ①如果把 null 或者 undefined 作为 this 的绑定对象传入 call、apply 或者 bind，这些值在调用时会被忽略，实际应用的是默认绑定的规则。 ###


## 4.this 和闭包一起用（拿不到this 和 arguments） ##

    `function bar(value){
    let name=value;
    let foo1=()=>{console.log(arguments[0])};
    let foo2=()=>{console.log(this.name)};
    let obj1={name:'C'};
    console.log(obj1.name)//C
    foo1();//yishifan
    foo2();//undefined
    // foo1.call(obj1);
    foo2.call(obj1);//undefined
	}
	bar('yishifan');`


## 5.闭包中通用变量 ##

    `let father=function(){
    let fatherName='B';
    let p=1;
    let son=function(){
        let sonName='A';
        console.log(`${sonName}is ${fatherName}'s son`);
        p+=10;
    }
    son();
    console.log(p);//11
    p+=20;
    console.log(p);//31
	}`