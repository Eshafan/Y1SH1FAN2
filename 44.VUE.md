# 1、MVVM开发模式的理解 #
> model：数据模型，数据和业务逻辑的处理

> view：ui视图，负责数据的展示

> viewmodel：负责监听model中的数据改变并且控制视图view的更新，处理用户交互操作

> model和viewmodel之间是双向绑定：model中的数据改变，会触发view刷新。view由于用户交互改变的数据也会在model中更新

> 前端将从model里拿出来的数据进一步封装，生成符合view的展示

>  ViewModel 所封装出来的数据模型包括视图的状态（数据本身）和行为（用户行为，数据如何变化）两部分




# 2、常见的vue指令 #
> v-html：输出html本身  v-show  v-if  v-for：用于数组遍历 v-bind：动态绑定一个或多个特性，绑定css属性（语法糖：）  v-model：在表单上创建双向数据绑定（.trim()方法：去除空格）（.number()方法：把输入变成数值类型）  v-on：监听dom事件（@语法糖）

    `事件修饰符（顺序也很重要）
	.stop()阻止事件继续传播，阻止冒泡=event.stopPropagation=
	.prevent()=event.preventDefault事件不再重载页面`
	.capture():使用捕获模式（自身先触发，再向里面传
	.self（)：只有在event.target是当前元素自身触发处理函数(不含子元素）
	.once（）触发一次
	.passive（）不组阻止事件默认行为（event.preventDefault)
	
# 3、v-if 和 v-show 的区别 #
都可以动态控制dom元素的显示与隐藏

> 是否还保存在dom树中，v-show：display在block和none中切换，dom元素还在，v-show节省开销（来回交替显示）注意：用v-show不能够让css本身是display：none的再展示回来（不能修改本身已经存在的css属性）

> v-if是将dom添加或者删除

> display：none（还在）   opacity：0（设置为透明）

> visibality:hidden(隐藏，还在）

    `v-if 和 v-for的优先级：v-for大，v-if会被应用到每一个子里面`


# 4、Vue的响应式原理 #
![](http://bbs.itheima.com/data/attachment/forum/202004/03/103201dloujwj1izzx1jw0.jpg.thumb.jpg)


## 4.1 object.defineproperty ##

    `const data={};
	let name1='VUE';

    Object.defineProperty(data,'name',{
        get: function(){//调用的时候是get
            console.log('get');
            return name1;
        },
        set:function(newValue){
            console.log('SET');  
            //视图重新渲染的工作
            name1=newValue;    //通过修改name1，调用的时候修改data.name    
            }
        }
    )
    console.log(data.name);
    data.name='React'
    console.log(data.name);

`
> 调用object.defineproperty，一旦要使用对象的name属性，那么就调用get方法，执行get里的代码，首先打印get，然后将data.name返回为外面变量name1的值，也就是VUE data.name='react' 是对对象里面的属性进行赋值，也就是要调用set方法，首先打印SET，然后将传进去的新的值给name1这个外部常量，由于name1和data.name是绑定在一起的，所以data.name在再一次调用的时候，又返回的是name1的值，在调用之前，data.name是没有改变的

> 只是改变的data里面一个简单的变量，如果是对象或者数组怎么办？

## 4.2 基本响应实现 ##

	    `const data={
	    name:'yishifan',
	    age:24
		}
		//变成响应式数据
		observer(data)
		function observer (target){
	    if(typeof target !=='object' || target ==null){//只有对象或者数组才能够实现这样变成响应式，如果是变量，则只用object.definproperty中的get（调用），set改变就可改成响应式
	        return target;//如果不是对象，直接返回，变量用其它方法响应
	    }
	    for(let key in target){//遍历对象里面的属性名
	        defineReactive(target,key,target[key])//target[key]就是属性的值
	        //定义函数：对象，属性，属性值 ，实现响应，
	        //相当于把每一个对象的属性，拿出来object.defineproperty，遍历（for in)
	    }
		}
		function defineReactive(target,key,value){
	    Object.defineProperty(target,key,{//这里相当于是更新单个基本变量
	        get:function(){//get 和 set 的两种写法都可以
	            return value;//取值直接去（这是默认方法）
	        },
	        set(newValue){
	            if(newValue!==value){//改值，不等才改，（也是默认方法）
	                value=newValue;
	                console.log('hello')
	            }
	        }
	    })
		}
		// data.age=21;
		// console.log(data.name)
		// data.name='NO AND YES';
		console.log(data.name)`
	
	> 改了之后，重新再一次答应，又变回了‘yishifan’，因为相当于重新执行代码
	
	> 以上虽然是对象里的变量，可以实现响应式了，但是其值都是数字或者字符串的形式，如果对象的属性是对象怎么办？
	
	> 解决以上方法（递归调用嵌套的对象）
	
			    `
		`
	
	const data={
	    name:'yishifan',
	    age:24,
	    friend:{
	        friendName:'xiaoliu'
	    }
	}
	//变成响应式数据
	observer(data)
	function observer (target){
	    if(typeof target !=='object' || target ==null){//只有对象或者数组才能够实现这样变成响应式，如果是变量，则只用object.definproperty中的get（调用），set改变就可改成响应式
	        return target;//如果不是对象，直接返回，变量用其它方法响应
	    }
	    for(let key in target){//遍历对象里面的属性名
	        defineReactive(target,key,target[key])//target[key]就是属性的值
	        //定义函数：对象，属性，属性值 ，实现响应，
	        //相当于把每一个对象的属性，拿出来object.defineproperty，遍历（for in)
	    }
	}
	function defineReactive(target,key,value){
	    observer(value);//相当于把friendName再拿进去递归去绑定
	    Object.defineProperty(target,key,{//这里相当于是更新单个基本变量
	        get:function(){//get 和 set 的两种写法都可以
	            return value;//取值直接去（这是默认方法）
	        },
	        set(newValue){
	            observer(newValue);//为了防止把一个基本变量设置生一个对象之后，再去改变它，监听不到的情况
	            if(newValue!==value){//改值，不等才改，（也是默认方法）
	                value=newValue;
	                console.log('hello')
	            }
	        }
	    })
	}
	// data.age=21;
	// console.log(data.name)
	// data.name='NO AND YES';
	data.friend.friendName='xiaowang';
	console.log(data.friend.friendName);`

> vue2里面的object.defineproperty的问题就是会有深度监听的情况，对对象里面的对象里面的属性进行递归监听，vue3里面的proxy就解决了这个问题

> 并且object.defineproperty还没有办法处理属性删除和属性新增的问题（vue.delete/vue.set)


## 4.3 处理值为数组的情况 ##
> 通过索引改变是ok的

    `data.colors.push('yellow');
`
> 以上方法对于原生的push方法，并不会改变视图，也就是没有实现响应式，通过以下方法，可以改变原本原型里面的方法，也就是push的原本方法之后，还要实现更新视图的绑定

		
		    `const oldArrayProto=Array.prototype;//Array.prototype也就是实例的_proto_,都是指向原型的
		//Array就是一个构造函数了
		const newArrayProto=Object.create(oldArrayProto);//通过原本的原型，直接创建一个实例（那是构造函数吗？？）不是（只是一个数组对象而已）
		//用原型去创建一个对象，新的原型，里面是没有方法的，可以实现修改本身的方法
		//意思就是构造函数不是原型的一个实例
		// console.log('old',oldArrayProto)//old Object(0) []
		// console.log('new',newArrayProto)//new Array {}
		// const instance =new newArrayProto;
		// console.log(instance)//Array {}
		['push','pop','shift','unshift','splice'].forEach(methodName=>{
		    newArrayProto[methodName]=function(){
		        console.log('更新视图');
		        oldArrayProto[methodName].call(this,...arguments);
		    }
		})
		
		
		
		//变成响应式数据
		observer(data)
		function observer (target){
		    if(typeof target !=='object' || target ==null){//只有对象或者数组才能够实现这样变成响应式，如果是变量，则只用object.definproperty中的get（调用），set改变就可改成响应式
		        return target;//如果不是对象，直接返回，变量用其它方法响应
		    }
		
		    if(Array.isArray(target)){
		        target._proto_=newArrayProto;//如果要实现响应式的是一个数组，则需要给该实例数组重新指定原型，方便数组里面再传数组，丢失了数组本身的方法
		    }
		`

> get被访问  set 被修改

# 5、vue如何在组件内部实现一个双向数据绑定 #

> 双向数据绑定如何实现：数据劫持 结合 发布订阅模式 核心object.defineproperty
## 5.1 父子 ##
> 父组件的任务：（1）给子组件传值（props）（2）监听事件，双向绑定改变自己的值

> props（父-子）

> $emit(子-父)


# 6、vue 如何监控某个属性值的变化 #
> watch：

> computed：（当依赖改变，便会重新计算一个新值）

# 7、vue中给data的对象属性添加一个新的属性会发生什么，如何解决 #

> 如果是实例创建之后添加的属性就不能够被响应式处理，所以就无法触发视图的更新，这时就用vue的全局api（vue.$set）相当于手动把某个属性处理成一个响应式的属性，同样，删除后，解除绑定（vue.delete)


# 8、delete 和 Vue.delete 删除数组的区别 #

> delete删除数组，数组长度不变，值变成empty

> Vue.delete删除数组后，数组长度改变

# 9、如何优化SPA应用的首屏加载速度慢的问题 #
> SPA（单页面应用）：只有一个html（包含大量js代码，为了实现交互）意思就是不用实现任何路由，首次加载必须加载全部html，js，css，因为获取资源是发起http请求，但是只有一个html，所以就要让服务器一次性给完，免得之后再联系

> MSP（多页面应用）：页面跳转时是整页刷新

> 不会再有整页的刷新 AJAX

    `优点：（1）良好的用户体验（切换）
		（2）前后端分离：可以在服务端分解静态页面和交互页面
		（3）减轻服务器压力：只用出数据，不用管展示逻辑和页面合成
		（4）公用一套后端程序代码：跨平台（web，手机，平板）`


    `缺点：（1）SEO（搜索引擎优化）很难，还不如做一些静态页面给搜索引擎，因为处理单页面应用的时候，页面不刷新，导致在里面记录的内容很难被搜索引擎搜索到
			（2）前进后退管理（不能使用浏览器的前进后退功能）
			（3）初次加载耗时`


    `优化：（1）js代码靠外部引用
			（2）懒加载
			（3）首屏提供loading图，提升用户体验`
> 
# 10、前端如何优化网站性能 #

 
> 10.1 减少http请求数量

    `css精灵图（切图）（只请求一次），拿一张大图

	合并css和js文件，利用打包工具

	利用懒加载：页面内容无需加载的时候，就不请求，当用户需要的时候，再请求，控制了网页一次性请求数量`

> 10.2 控制资源文件加载优先级

    `css提前，为了第一时间展示页面给用户，js在底部，免得操作dom树，影响js 的从上往下加载`

> 10.3 利用浏览器缓存（强缓存，协商缓存（304))

> 10.4减少重排（reflow）也叫回流

> 10.5 减少DOM操作

# 11、网页从输入网址到渲染完成了那些过程 #

> 1、输入网址

> 2、DNS解析（解析出ip地址）

    `两种方法（递归（一定找到弟弟），迭代）
	递归：从本地域名服务器，到根域名路由器，到顶级域名服务器，到权限域名服务器（一定有）

	迭代：让本地域名服务器当作代理，先找根、顶级、权限，一般用迭代）`

> 3、建立tcp连接（3次握手）

> 4、发送http请求

> 5、web服务器响应，并返回指定数据的url（或者错误信息，或者重定向的url）

> 6、浏览器下载web服务器返回的数据或者解析html文件

> 7、生成dom树，解析css和js，渲染页面


# 12、Vue 核心思想：数据驱动，组件化 #

> 1、数据驱动：（不是手动操作DOM）而DOM是数据的一种自然映射，传统的是通过ajax请求从model请求数据，然后手动触发dom传入数据，修改页面

> 2、响应原理：把一个对象传给vue实例的data选项：遍历它的所有属性，使用object.defineproperty()把这些属性全部转为getter/setter，每个钻剑实例都有响应的watcher实例对象，他会在组件渲染的过程中在setter被调用时，重新计算

> 3、组件化：页面是组件的容器，方便维护，重用

# 13、vue2和vue3生命周期的区别 #
> 生命周期函数：某个时刻自动执行

    `
	（1）destroyed====>mounted

	 (2) beforecreate+created=set up
	`


> 生命周期函数___(初始化事件和生命周期函数）___beforeCreate____(初始化依赖注入和响应式）—_____created(vue实例创建完毕data，method）____（判断有没有template选项）（yes：编译模板并与数据结合准备渲染页面   no：没有模板，就把html里面的内容当作模板））____beforeMount（模板渲染在页面之前）____mounted(模板渲染到页面完毕的时候，页面上就有东西了）______beforeupdate（只改准备渲染）______updated（渲染到页面之后，html里面的内容改变）______beforedestroy（vue不再控制dom元素，此时组件内容还在）______destroy（全部移除完毕）


# 14、组件data为什么是一个函数 ，并且return一个对象#

> 因为组件复用，js里的对象是引用关系，组件中的data是一个对象，这样所有实例都共用

> 为了每个实例可以维护一份独立的拷贝对象，不相互印象

# 15、vue组件之间的通信方式 #

> props/$emit



# 16、computed 和 watch 的区别和应用场景 #

> computed：一个属性受多个属性影响（购物车结算价格）

> watch：一个数据影响多条数据（搜索出来多个结果）

# 17、如何让css只在当前组件中起作用 #
    `style scoped（彻底仔细看）`

# 18、<keep-alive></keep-alive> #
> 使被渲染组件避免重新渲染

# 19、如何获取dom #
> ref=‘domName’  用法：this.$refs.domName

# 20、为什么要使用key #
> 给每个节点（dom树中的）添加一个唯一标识，diff算法就可以正确识别该节点，为了高效更新dom树

# 21、v-model #
> 用于表单数据（注意是表单数据）的双向绑定

> 是一个语法糖，实际上：v-bind+value（表单的数值）或者v-on+input（表单的输入框，是一个事件）

# 22、vue项目中src每个文件的用法 #

> 1、assets：存放静态资源（资产，财产）
    `assets和static的区别：都是用来存放静态资源
	assets在项目打包时，会打包上传，压缩体积，代码格式化，而static就不会压缩格式，而是直接打包`

> 2、components：存放组件

> 3、router：定义路由

> 4、app.vue：应用主组件

> 5、main.js：入口文件


# 23、$nextTick #

> 修改数据的值后，并不能马上在dom中得到这个修改后的值，而需要使用这个回调，才会渲染到dom元素中

> Vue 实现响应式并不是数据发生变化之后 DOM 立即变化，而是按一定的策略进行 DOM 的更新

> created中应该包含nexttick，不然都没有渲染到dom中，created操作的是什么？created后，页面渲染就完成了，也要有数据的啊

> Vue是异步执行dom更新的，一旦观察到数据变化，Vue就会开启一个队列，然后把在同一个事件循环 (event loop) 当中观察到数据变化的 watcher 推送进这个队列。

> vue修改dom是异步，一旦数据变化，就推入事件队列等着，如果在这个期间又变化，就不管。推入的是watcher。意思就是还是检测到了变化。在队列中的位置不变。等这次更新全部结束后，才去修改dom，如果在修改dom之前，对修改后的数据进行操作，就会报错，所以才要引入nexttick，是不等。马上对dom修改

# 24、引进组件的步骤 #
> 1、template （模板中引入）

> 2、script第一行 用import引入路径

> 3、component中写入组件名称

# 25、路由跳转： router.push('/url')来跳转，使用了diff算法，实现了按需加载，减少了dom的消耗。#

# 26、 slot作用域插槽（父向子传内容的时候用）#

> 父组件要在子组件中放dom，那么选择性的放

> 具名插槽，特别是使用在循环遍历父组件传来的值，而每一个子组件只显示其中一个属性值

# 27、axios是一个基于promise的http库 #
    `import axios from 'axios'
`
> 前端通信框架：vue只是用来处理dom，由axios来与服务器进行交互，也可以使用jquery提供的ajax（都是异步）

> axios的功能特点

    `1、从浏览器中创建：xmlhttp requsest
	 2、从node.js创建http请求
	 3、拦截请求和响应
	 4、转换请求数据和响应数据
	 5、取消请求
	 6、自动转换json数据
	 7、客户端支持防御xsrf`

# 28、封装vue组件的过程 #
> 
> 1、vue.extend()创建一个组件

> 2、vue.component()注册组件

> 3、如果子组件需要数据，通过props传值

> 4、如果要向父组件传值，则用emit方法

> 组件全局注册：vue.component

> 组件局部注册：components属性


# 29、params 和query的区别 #

> query===》path（在url中直接显示，刷新不会丢失里面的数据，类似于get）

> params===》name 类似于post

# 30、vue初始化页面闪动问题 #

> 造成原因：vue还没有管到html里面的div

> 解决办法：【v-clock】加在html中

> 在css中添加display:none;

# 31、vue常用ui组件库 #
> mint ui    element  vux

# 32、路由的两种模式 #
> hash：在地址栏中的#

> history模式


# 33、vuex是什么，怎么使用，哪里用 #
> vue框架中的状态管理

> 单页应用，音乐播放，登陆状态，加入购物车

> vuex的5种属性：state => 基本数据(数据源存放地)
getters => 从基本数据派生出来的数据
mutations => 提交更改数据的方法，同步！
actions => 像一个装饰器，包裹mutations，使之可以异步。
modules => 模块化Vuex