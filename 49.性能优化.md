#1、浏览器的功能 #
> 网络、资源管理（下载的时候确认存放的位置）、网页浏览、多页面管理（多窗口）、插件、账户同步机制、安全机制、开发者工具


# 2、浏览器的内核：把一切请求回来的资源变为可视化的图像 #

> IE==========》 Trident

> safari=====》webkit（webcore/jscore））

> chrome=====》webkit的分支引擎===》Blink

> opera====》Blink

> Firefox======》Gecko


# 3、进程线程 #
> 操作系统和cpu的调度单位

> cpu多核多线程（同时处理多个任务）

> 调度算法：先来先服务（饿死）/优先级/时间片轮转/高响应比

> 工厂&&工人

> js是单线程运行的（事件轮询机制）===》推入事件队列

# 4、现代浏览器：多进程、多线程 #
## 浏览器的进程 ##
> Browser 进程（负责其它进程的创建和销毁）（一定有）

> Render 进程（负责网页的渲染)（一定有）

> 插件 进程：各种开发工具/访问助手

> GPU进程

> 每个进程内部又有很多线程：多线程的目的主要是保持用户界面的高度响应

> 

> 管线化（疯狂开启进程线程）====》抢占cpu（将渲染过程管线化）


# 5、浏览器渲染引擎 #
## 1、主要模块5个 ##
    `
	①HTML解析器：HTML====>DOM树
	②CSS解析器：DOM中各个元素对象计算出样式信息，为布局提供基础设施（写的red代表红色）
	③javascript引擎：解释js代码，通过DOM接口操作DOM节点
	④布局layout模块：结合DOM和css出来的样式（指定的模块摆在那里）
	⑤绘图模块：样式（软装修）
	DOM==>document object model 文档对象模块
	`
## 2、大致渲染过程 ##

    `
	解析：可以进行渲染了（浏览器在读代码）
	渲染：能看见东西了
	①遇见HTML===>HTML解析器解析为对应的token(一个token就是一个标签文本的序列化，都是div，但是要通过token区分)构建DOM树
	②遇见style/link===>调用响应的解析器（style是被html解析的，样式推荐用link来引入）处理css
	
	③遇到script，调用js引擎，处理script标记，绑定事件，修改DOM树/CSS树
	④DOM树+CSS树===渲染树（因为js既可以动解构，又可以动样式，所以在script后面搞）==》GPU
	⑤根据渲染树确定几何信息
	⑥绘制到屏幕上去

`
## 3、style样式的渲染（无style/用style/用link） ##
### style ###
	`
	send request===》receive response===》receive data===》
	parse data===》parse html===>receive data===> parese html(大的话就分几次拿数据，解析html)
	===》finish loading ===》recaculate style===》layout===》update layer tree===》paint===》composite layers
	`    
> 闪屏：刚开始一堆不相关的东西，突然全部布局又好了====》同一个div多个样式改过去改过来的，还不如确定最终的效果，能看的（用style标签写样式就会造成这种现象）====》结构先出现在页面，而没有样式

> 浏览器拿资源是异步的，免得在拿资源的时候白等（继续更新图层，计算样式）

> 不用style：不便于维护/闪屏（用link来解决）

### link ###
	`send request===》receive response===》receive data===》finish loading ===》parse html（send request/send request）===>有多个html解析器（还是按顺序）还是一点一点往回加（由大小决定谁先回来）====》parse stylesheet===》
	
`