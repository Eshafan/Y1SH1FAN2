# 二分查找主要是针对的是**有序**存储的数据集合 #

## 方法一 ##
    `function binarySearch(nums,target){
    let left = 0,right = nums.length-1;
    while(left<=right){
    let mid = (left+right)/2;
    if(target==nums[mid]){
        return mid;
    }
    else if(target>nums[mid]){left=mid+1}
    else if(target<nums[mid]){right=mid-1}
    else {return -1}
    }
	}
	console.log(binarySearch([1,3,4,5,6,7,8,9,10,14,17],7))//5`


## 方法二 ##

    `function binarySearch(nums,target){
    let left = 0,right = nums.length-1;
    while(left<=right){
    let mid = (left+right)/2;
    if(target==nums[mid]){
        return mid;
    }
    else if(target>nums[mid]){
        nums.splice(mid+1,nums.length-1)
    }
    else if(target<nums[mid]){
        nums.splice(left,mid-1)
    }
    else {return -1}
    }
	}`

## 时间复杂度分析：log2（n） ##
### 原因分析：第一次n/2 ###
### 		 第二次n/4 ###
### 		 第三次n/8 ###
：
### 		 第m次n/（2^m) ###
### 查找的总次数：n/（2^m)=1 ###


