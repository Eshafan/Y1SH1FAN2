# 跨域的根本原因：浏览器的同源策略（其实请求发出去了，并且服务器返回了，只是返回的结果被浏览器给截获了 #

    `跨域的几种情况：（1）协议不同（只能用服务器反向代理解决）
					（2）端口不同
					（3）主域相同，子域不同，a.baidu.com vs
 						b.baidu.com
					(4)不同域名对应同一个ip地址也叫跨域`



> 解决方法：

    `1、document.domain=》解决主域相同，子域不同的情况
	只能把该值设置成自己或者父域，前提条件是主域必须相同 
	例如：a.b.example.com 则可以设置为：a.b.example.com
	b.example.com  example.com,这样两个设置相同的document.domain是可以互相访问的
	优点：实现不同window对象之间相互访问和操作
	缺点：只能在主域相同，子域不同的情况下使用
	 2、window.name+iframe
	 3、location.hash+iframe
	 4、jsonp：只能用get请求，后端需要知道前端的cb是什么样的结构才好传参，cb是在客户端，利用script标签
	 5、postMessage：h5引入的，类似于广播方式，所以安全性无法保证
	 6、cros，兼容性
	 7、同域代理：最常用`




# 1.CORS 跨域资源共享(接口控制允许）缺点：兼容性差#
## 1.1CORS请求的简单请求和非简单请求 ##
它允许浏览器向跨源服务器，发出XMLHttpRequest请求，从而克服了AJAX只能同源使用的限制。
#### 需要浏览器和服务器同时支持（关键是看服务器是否实现了CORS接口） ####
### 1.1.1 简单请求GET、POST、HEAD（simple request）同时满足以下条件###
#### ①请求方法：head/get/post（用options（非简单）去问） ####
#### 补充get/post/put/delete 查/增/改/删 ####
#### ②http头部只有以下几个字段 ####
    `Accept
	Accept-language
	content-language
	last-event-id
	content-type`

### 对于简单请求，浏览器直接发出cors请求，只需要在头部信息中，增加一个origin字段access-control-allow-origin ###
    `Origin: http://api.bob.com`
根据这个字段说明此次请求来自哪个源，是客户端的ip地址，如果这个源不在许可范围之内，服务器就返回一个正常的http回应，但是浏览器会发现这个头部不包含`Access-Control-Allow-Origin`字段
#### 如果服务器同意它访问，则响应头中会多出几个部分 ####
    `Access-Control-Allow-Origin: http://api.bob.com
	Access-Control-Allow-Credentials: true//是否允许发送cookie（开发者必须在AJAX请求中打开withCredentials属性）
	Access-Control-Expose-Headers: FooBar//发起cors请求时，服务器给的响应头默认只有当前几个，需要多的就需要设置
	Content-Type: text/html; charset=utf-8`
#### 如果要发送Cookie，Access-Control-Allow-Origin就不能设为星号，必须指定明确的、与请求网页一致的域名 ####

### 1.1.2非简单请求（not-so-simple request）：PUT、DELETE ###
因为put是改，需要得到服务器的允许，而post提交，是用户拿给服务器的新值，服务器还要考虑放在哪里
#### 非简单请求的CROS请求，会在正式通信前，增加一次http查询请求，称为“预检”请求 ####
### "预检"请求用的请求方法是OPTIONS，表示这个请求是用来询问的 ###
    `（1）Access-Control-Request-Method

	该字段是必须的，用来列出浏览器的CORS请求会用到哪些HTTP方法，上例是PUT。
	
	（2）Access-Control-Request-Headers
	
	该字段是一个逗号分隔的字符串，指定浏览器CORS请求会额外发送的头信息字段，上例是X-Custom-Header。`
### 预检的请求头 ###
    `OPTIONS /cors HTTP/1.1
	Origin: http://api.bob.com //来自哪个域
	Access-Control-Request-Method: PUT//必须的字段
	Access-Control-Request-Headers: X-Custom-Header//必须字段
	Host: api.alice.com //
	Accept-Language: en-US
	Connection: keep-alive
	User-Agent: Mozilla/5.0…`
### 预检的响应头 ###
    `HTTP/1.1 200 OK
	Date: Mon, 01 Dec 2008 01:15:39 GMT
	Server: Apache/2.0.61 (Unix)
	Access-Control-Allow-Origin: http://api.bob.com
	Access-Control-Allow-Methods: GET, POST, PUT
	Access-Control-Allow-Headers: X-Custom-Header
	Content-Type: text/html; charset=utf-8
	Content-Encoding: gzip
	Content-Length: 0
	Keep-Alive: timeout=2, max=100
	Connection: Keep-Alive
	Content-Type: text/plain`


## 为什么要分简单请求和非简单请求：非简单请求会使服务器比简单请求的多一倍的压力（相当于获取服务器的允许） ##
# 简单请求就是使用设定的请求方式请求数据，而非简单请求则是在使用设定的请求方式请求数据之前,先发送一个OPTIONS请求,看服务端是否允许客户端发送非简单请求.只有"预检"通过后才会再发送一次请求用于数据传输 #