# 1、冒泡排序 稳定 o（n^2） #
    `function bubbleSort(nums){
    let len= nums.length;
    let tag=1;
    for(let i=0;i<len-1;i++){  
        tag=0;
        for(let j=0;j<len-1-i;j++){
            if(nums[j]>nums[j+1]){
                let temp=nums[j];
                nums[j]=nums[j+1];
                nums[j+1]=temp;
                tag=1;
            }
        }
        if(tag==0) break;
    }
    return nums;
	}
	console.log(bubbleSort([1,4,5,6,7,3,2,4,6]))`

#### 解析稳定性：在算法中，只是大于才进行交换，所以保证了它的稳定性 ####
#### 时间复杂度：两层for循环，所以是n^2 ####

# 2.选择排序 不稳定 O(n^2) #
    `function selectSort(nums){
    let len = nums.length;
    for(let i =0;i<len-1;i++){
        for(let j=i+1;j<len-1;j++){
            if(nums[j]<nums[i]){
                let temp=nums[i];
                nums[i]=nums[j];
                nums[j]=temp;
            }
        }
    }
    return nums;

	}
	console.log(selectSort([1,4,5,6,7,3,5,6,7,8,9,12,13]))`
> 解释不稳定的原因：127745（4和7交换的时候，把后面的7换到了前面去，所以造成不稳定

> 时间复杂度解释：第一次n-1 第二次n-2 第三次n-3，最多执行n-（n-1）次，所以是n^2

# 3.插入排序 稳定 O（n^2)  #
## 每一次都要实现向后移动 ##

    `function innertSort(nums){
    let len= nums.length;
    for(let i=0;i<len-1;i++){
        let current= nums[i+1];
        let index=i;
        while(index>=0 && current<nums[index])
            {
                nums[index+1]=nums[index]
                index--;
            }
        nums[index+1]=current;
        }
        
    return nums;
	}
	console.log(innertSort([4,6,7,2,1,3,5,6,7,9]))`

> 稳定性分析：因为在代码中只选择比它小的进行插入

> 时间复杂度分析：第一次比较1个，依次类推，比较n次，最多依次比较n-1个。所以是n^2

# 4.快速排序 不稳定  O(nlog2(n))  #
> 思路：选基准点，比基准点小的放在左边，比基准点大的，放在右边，再在两边分别再选基准点


    
> 错误原因：用了递归，但是没有给出口，长度小于等于1就该return出口了
    `        if(nums.length<=1){
            return nums;
        } 就是这句，出口没有定义`

    

    `function quickSort(nums){
    if(nums.length<=1){
        return nums;
    }
    let midIndex = Math.floor(nums.length/2);
    let target= nums.splice(midIndex,1)[0];
    let left=[];
    let right=[];
    for(let i =0;i<nums.length;i++){
        if(nums[i]<target){
            left.push(nums[i])
        }
        else{
            right.push(nums[i])
        }
    }
    return quickSort(left).concat([target],quickSort(right))
	}`
> 分析稳定性：大于等于的都放在了右边，如果中间有两个相等的数12344567，如果是这种，选中第一个4不会引起不稳定，如果选中第二个4，则就会引起不稳定

> 时间复杂度分析：分的时候分n/2次，n/4次，n/2^m 次 n/2^m=1推出 m=log2(n),然后有n次

# 5.归并排序 稳定  O(nlog2(n))#
> 算法思想：先分成两个进行排列，再两两合并，再四四合并，最后全部合并。是一种递归


# 6.堆排序 不稳定  #
> 需要是一颗完全二叉树（从上往下从左往右依次生成） 堆：父节点要大于子节点的值

> 要么去建立大顶堆（从大到小），要么去建立小顶堆（从小到大），每次调整完成后，取出顶元素，然后用最下面的数去替换