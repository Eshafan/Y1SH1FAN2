# 1、排序算法的考点 #

> （1）冒泡排序
    
	`稳定（因为可以自己确定到底是大于还是大于等于，两层从0-n的for循环决定了它的时间复杂度`

    //1、冒泡排序O（n2）记得用flag
	var bubbleSort=function(nums){
    let len =nums.length;
	let flag=0
    for(let i=0;i<len;i++){
        for(let j=0;j<=len;j++){
            if(nums[j]>nums[j+1]){//这里决定了稳定性
                let temp=nums[j];
                nums[j]=nums[j+1];
                nums[j+1]=temp;
				flag=1;
            }
        }
	if（flag==1）break；
    }
  		return nums;
	}

> （2）快速排序

    `不稳定（找pivot）把小于的放左边，把大于等于的放右边，如果是13345（则第一个3就会跑到后面去，造成了不稳定性`


    `function quickSort(nums){
    if(nums.length<=1){
        return nums;
    }
    let midIndex = Math.floor(nums.length/2);
    let target= nums.splice(midIndex,1)[0];
    let left=[];
    let right=[];
    for(let i =0;i<nums.length;i++){
        if(nums[i]<target){
            left.push(nums[i])
        }
        else{
            right.push(nums[i])
        }
    }
    return quickSort(left).concat([target],quickSort(right))
	}`



> RangeError: Maximum call stack size exceeded  总是报错，还没有找到原因


> （3）选择排序（每次选最小的，放在最前面）

    `不稳定，因为456473这种情况，3和第一个4交换的时候，把这个4给换到了后面去。所以造成了不稳定`


    `var selectSort=function (nums) {
        let len = nums.length;
    for(let i = 0;i<len;i++){
        for(let j=i;j<len;j++){
            if(nums[j]<nums[i]){
                let temp=nums[i];
                nums[i]=nums[j];
                nums[j]=temp;
            }
        }
    }
    return nums;  
        
    }`




# 2、线性表的链式存储结构 #
> 因为顺序存储的插入或这删除会涉及大量元素的移动，影响效率




> 反转链表

	`var reverseList = function(head) {
    var prev=null,cur=head,temp;
    while(cur){
        temp=cur.next;
        cur.next=prev;
        prev=cur;
        cur=temp;
    }
    return prev;


	};`
> 其实就是交换两个指针元素，一定要注意不要让指针丢了，一定要暂存指针