# 1、vuex概述 #
> 1.1 组件之间共享数据的方式

> 父传子：v-bind 属性绑定（props）

> 子传父：v-on 事件绑定（emit）

> 兄弟组件之间共享数据：EventBus



## 1、什么是vuex：实现组件全局状态，方便实现组件之间数据的共享 ##
> 使用vuex管理状态的好处：1、集中管理共享的数据：易于开发和维护 2、高效的实现数据之间的共享，提高开发效率  3、存储在vuex里面的都是响应式的，能够时时保持数据与页面同步


## 2、什么样的数据适合存储在vuex中 ##
> 组件之间共享的数据放在里面，不共享的数据放在data里面就可以了

## vuex是单独一个文件存放它里面的类似于属性的东西，store.JS 已经导入要应用的组件里面了 ##

# 2、vuex的基本使用 #

    `1、安装依赖包：npm install vuex  --save`


    `2、导入vuex：import Vuex from ’vuex‘
		Vue.use(vuex)安装在项目里`

	3、创建store对象
	const store=new Vuex.store({
	state:{count:0}//全局共享的数据count，默认为0
	})

	4、将store对象挂载到vue实例中
	new Vue({
		el:'#app',
		render:h=>(app),//渲染app组件
		router,//挂载路由
		store//创建的共享数据挂载进去
	})

# 3、vuex中的核心概念 #

## 3.1 state（状态）：提供唯一数据源，所有的数据都要统一放到store中的state存储 ##

    `const store=new Vuex.store({
	state:{count:0}//全局共享的数据count，默认为0
	})`

> 1、组件访问state中数据的第一种方式：this.$store.state.全局数据名称（this可以省略，因为在template中）


> 2、组件访问state中数据的第一种方式：

> （1）从vuex中按需导入mapState函数
    `import{mapState}from ‘vuex’`//这是vuex中固有的

> （2）将全局数据，映射为当前组件的计算属性

    `computed：{
	...mapState{['count']}`
	}

## 3.2 Mutation（突变/改变）：用于变更数据的值 ##
> 只有它能修改state里面的数据

> 因为在vuex中，不推荐直接修改store中变量的值，因为都跟着一起改了，并且不知道是谁改的
> 


    `const store=new Vuex.store({
	state:{count:0}//全局共享的数据count，默认为0

	mutations：{//mutations带了s的
	add(state){//state指的就是state对象
		state.count++
	}}
	})`

> 在相应需要改变的组件中触发mutation
    `
	methods:{
		handle1(){//定义一个函数方法，是onclick调用的
		this.$store.commit('add')//通过commit来调用
	}	
	}
`

### 向mutation定义的函数中进行传值（定义函数时进行传值）###

 	` const store=new Vuex.store({
	state:{count:0}//全局共享的数据count，默认为0

	mutations：{//mutations带了s的
	addN(state，step){//state指的就是state对象
		state.count+=step
	}}
	})``


	methods:{
		handle1(){//定义一个函数方法，是onclick调用的
		this.$store.commit('addN',3)//通过commit来调用,其作用就是调用某个mutation，第二个参数进行传值
	}	
	}

> 触发mutation的第二种方式（第一种方式是 this.$store.commit('mutation里面的函数'，参数））

> 第二种方式：

> 1、从vuex中按需导入mapMutation函数
    `import {mapMutation} from ‘vuex’`

> 2、将指定的mutation函数，映射为当前组件的methods函数
> //在要使用的组件中用
    `methods：{
	...mapMutation{['add','addN]}}	`

### 实现延时操作sttimeout，在mutation中的函数搞 ###
> 页面改变了。但是调试器里数据没有改变。所以mutation里面的函数不能使用异步代码（不能使用调试器）

# 3.3 Aution 用于处理异步任务(只能访问mutation） #
> 在action中不能直接修改state中的数据，只能通过context.commit()去触发mutation里面的函数去修改。action的作用只是为了异步


> 如果通过异步操作变更数据，必须通过action，而不能使用mutation。但是在action中还是要通过触发mutation的方式间接变更数据


    `const store=new Vuex.store({
	
	state:{count:0}

	mutations：{
		add（state){
		state.count++
		}	}

	action：{
		addAsync（context）{
		setTimeout（（）=>{
			context.commit('add')},1000}//commit只能触发mutations里面的函数
	})``



> 从组件中触发action `

    `methods：{
		handle（）{
			this.$store.dispatch('addAsync')
		}//dispatch函数专门用来触发action
	}`


> 主要是为了解决异步事件监听器监听不到


### 触发action时携带参数（也是dispatch里面携带第二个参数）对于收到的参数，直接传给mutation ###


## 触发action 的第二种方（第一种方式是：this.$store.dispath(),在要调用的组件中使用） ##

### 第二种方式： ###

> 1、从vue中按需导入mapActions 函数
    `import {mapAction} from ‘vuex’}`

> 2、methods：{

       ...mapAction{['addAsync','addNAsync']}         }

# 3.4 Getter:对store中的数据进行加工处理形成新的数据，但是不会修改原来的数据。起到包装作用，类似于computed属性，store中的数据变化，则getter的数据也会跟着变化 #

    `getters:{
		showNum:state=>{
		return 新数据
		}`


> 使用getter1

    `this.$store.getters.名称`

> 使用getter2
    `import{mapGetters} from ‘vuex’}`

    `computed:{
	...mapGetters{['showNum']}
	}`//注意这里是在computed属性中调用的，其它的都是在methods中调用的